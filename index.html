<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Solana Token Launchpad</title>

<style>
body {
  font-family: system-ui, sans-serif;
  background:#0f0f1a;
  color:#e0e0ff;
  padding:1rem;
}
.container { max-width:480px; margin:auto; }
.card {
  background:#1a1a2e;
  padding:1.5rem;
  border-radius:16px;
  border:1px solid #334155;
}
button, input, textarea, select {
  width:100%;
  padding:.8rem;
  margin-bottom:1rem;
  border-radius:10px;
  border:1px solid #334155;
  background:#111827;
  color:white;
}
button {
  background:#7c3aed;
  font-weight:bold;
  cursor:pointer;
}
.warning {
  background:rgba(245,158,11,.15);
  border:1px solid #f59e0b;
  padding:1rem;
  border-radius:12px;
  margin-bottom:1rem;
}
</style>
</head>

<body>
<div class="container">

<h2>Solana Token Launchpad</h2>

<div class="warning">
‚ö†Ô∏è Devnet by default. Mainnet uses REAL SOL.
</div>

<div class="card">

<select id="network">
  <option value="devnet" selected>Devnet (testing)</option>
  <option value="mainnet-beta">Mainnet (REAL SOL)</option>
</select>

<button id="walletBtn">Connect Phantom</button>

<form id="form">
  <input id="name" placeholder="Token Name" required>
  <input id="symbol" placeholder="Symbol" maxlength="8" required>
  <input id="supply" type="number" placeholder="Total Supply" required>
  <input id="image" placeholder="Image URL (https://...png)">
  <textarea id="description" placeholder="Description"></textarea>
  <button type="submit">Launch Token</button>
</form>

</div>
</div>

<!-- LIBRARIES -->
<script src="https://unpkg.com/@solana/web3.js@latest/lib/index.iife.min.js"></script>
<script src="https://unpkg.com/@solana/spl-token@latest/lib/index.iife.min.js"></script>
<script src="https://unpkg.com/@metaplex-foundation/mpl-token-metadata@latest/dist/index.iife.js"></script>

<script>
const { 
  Connection, clusterApiUrl, Transaction, SystemProgram, Keypair, LAMPORTS_PER_SOL, PublicKey 
} = solanaWeb3;

const { 
  TOKEN_PROGRAM_ID, MINT_SIZE,
  getMinimumBalanceForRentExemptMint,
  createInitializeMintInstruction,
  getAssociatedTokenAddress,
  createAssociatedTokenAccountInstruction,
  createMintToInstruction,
  createSetAuthorityInstruction,
  AuthorityType
} = splToken;

const { 
  createCreateMetadataAccountV3Instruction,
  PROGRAM_ID: METADATA_PROGRAM_ID 
} = mplTokenMetadata;

// State variables
let wallet = null;
let connection = new Connection(clusterApiUrl('devnet'), 'confirmed');
let isConnecting = false;

// DOM elements
const walletBtn = document.getElementById('walletBtn');
const form = document.getElementById('form');
const networkSelect = document.getElementById('network');
const statusDiv = document.createElement('div'); // For feedback messages
statusDiv.style.marginTop = '1rem';
statusDiv.style.padding = '1rem';
statusDiv.style.borderRadius = '12px';
form.parentNode.insertBefore(statusDiv, form);

// Helper: Get Phantom provider (robust)
function getProvider() {
  // Prefer window.solana (common). Fallback to window.phantom?.solana if present.
  const solanaProvider = window.solana && window.solana.isPhantom ? window.solana : null;
  const phantomNamespaceProvider = window.phantom?.solana && window.phantom?.solana.isPhantom ? window.phantom.solana : null;
  const provider = solanaProvider || phantomNamespaceProvider;
  return provider || null;
}

// Disable/enable form
function toggleForm(disabled) {
  form.querySelectorAll('input,textarea,button,select').forEach(el => el.disabled = disabled);
}

// Show status message
function showStatus(msg, isError = false) {
  statusDiv.textContent = msg;
  statusDiv.style.background = isError ? 'rgba(239,68,68,0.15)' : 'rgba(34,197,94,0.15)';
  statusDiv.style.border = `1px solid ${isError ? '#ef4444' : '#22c55e'}`;
  statusDiv.style.color = isError ? '#fecaca' : '#bbf7d0';
}

// Update button text
function updateWalletButton() {
  if (wallet?.publicKey) {
    const pk = wallet.publicKey.toString();
    walletBtn.textContent = pk.slice(0,6) + '‚Ä¶' + pk.slice(-4);
    toggleForm(false);
  } else {
    walletBtn.textContent = 'Connect Phantom';
    toggleForm(true);
  }
}

// Network change
networkSelect.onchange = () => {
  connection = new Connection(clusterApiUrl(networkSelect.value), 'confirmed');
  if (networkSelect.value === 'mainnet-beta') {
    if (!confirm('‚ö†Ô∏è Switching to MAINNET ‚Äî real SOL will be spent! Continue?')) {
      networkSelect.value = 'devnet';
      connection = new Connection(clusterApiUrl('devnet'), 'confirmed');
    }
  }
  showStatus(`Connected to ${networkSelect.value.toUpperCase()}`);
};

// Connect handler
async function connectWallet(eager = false) {
  if (isConnecting) return;
  isConnecting = true;
  walletBtn.disabled = true;
  walletBtn.textContent = eager ? 'Auto-connecting...' : 'Connecting...';

  try {
    const provider = getProvider();
    if (!provider) {
      showStatus('Phantom not detected! Make sure you\'re using Phantom\'s in-app browser (globe icon).', true);
      throw new Error('No Phantom provider');
    }

    const params = eager ? { onlyIfTrusted: true } : {};
    const resp = await provider.connect(params);

    wallet = { publicKey: resp.publicKey };
    showStatus('Connected successfully! üéâ');
    updateWalletButton();
  } catch (err) {
    console.error(err);
    if (err?.code === 4001) {
      showStatus('Connection rejected by user.', true);
    } else {
      showStatus('Connection failed: ' + (err?.message || 'Unknown error'), true);
    }
    updateWalletButton();
  } finally {
    isConnecting = false;
    walletBtn.disabled = false;
  }
}

// Try eager connection on load (if previously trusted)
window.addEventListener('load', () => {
  connectWallet(true);
});

// Manual connect button
walletBtn.onclick = () => connectWallet(false);

// Safe data-uri building for JSON metadata (handles unicode)
function jsonToDataUri(obj) {
  const json = JSON.stringify(obj);
  // Safe unicode handling for btoa
  const utf8Bytes = new TextEncoder().encode(json);
  let binary = '';
  for (let i = 0; i < utf8Bytes.length; i++) {
    binary += String.fromCharCode(utf8Bytes[i]);
  }
  return 'data:application/json;base64,' + btoa(binary);
}

// Form submission
form.onsubmit = async (e) => {
  e.preventDefault();
  if (!wallet?.publicKey) return;

  const name = document.getElementById('name').value;
  const symbol = document.getElementById('symbol').value;
  const supply = document.getElementById('supply').value;
  const image = document.getElementById('image').value || '';
  const description = document.getElementById('description').value || '';
  const decimals = 9;

  const provider = getProvider();
  if (!provider) return showStatus('Lost wallet connection!', true);

  try {
    showStatus('Preparing transaction...');

    // Check balance
    const balance = await connection.getBalance(wallet.publicKey);
    if (balance < LAMPORTS_PER_SOL * 0.005) {
      throw new Error('Insufficient SOL balance for fees and rent (need ~0.005 SOL)');
    }

    const mint = Keypair.generate();
    const lamports = await getMinimumBalanceForRentExemptMint(connection);
    const tokenAta = await getAssociatedTokenAddress(mint.publicKey, wallet.publicKey);

    const [metadataPDA] = PublicKey.findProgramAddressSync(
      [Buffer.from('metadata'), METADATA_PROGRAM_ID.toBuffer(), mint.publicKey.toBuffer()],
      METADATA_PROGRAM_ID
    );

    // Embedded metadata URI (safely encoded)
    const metadataJson = {
      name,
      symbol,
      description,
      image,
      attributes: [],
      properties: {
        files: image ? [{ uri: image, type: 'image/png' }] : [],
      }
    };
    const uri = jsonToDataUri(metadataJson);

    const metadataData = {
      name,
      symbol,
      uri,
      sellerFeeBasisPoints: 0,
      creators: [],
      collection: null,
      uses: null
    };

    const tx = new Transaction();
    tx.add(
      SystemProgram.createAccount({
        fromPubkey: wallet.publicKey,
        newAccountPubkey: mint.publicKey,
        space: MINT_SIZE,
        lamports,
        programId: TOKEN_PROGRAM_ID,
      }),
      createInitializeMintInstruction(
        mint.publicKey,
        decimals,
        wallet.publicKey,
        wallet.publicKey // Freeze authority
      ),
      createAssociatedTokenAccountInstruction(
        wallet.publicKey,
        tokenAta,
        wallet.publicKey,
        mint.publicKey
      ),
      createMintToInstruction(
        mint.publicKey,
        tokenAta,
        wallet.publicKey,
        // safer BigInt math
        BigInt(supply) * (BigInt(10) ** BigInt(decimals))
      ),
      createCreateMetadataAccountV3Instruction(
        {
          metadata: metadataPDA,
          mint: mint.publicKey,
          mintAuthority: wallet.publicKey,
          payer: wallet.publicKey,
          updateAuthority: wallet.publicKey,
        },
        {
          createMetadataAccountArgsV3: {
            data: metadataData,
            isMutable: true,
            collectionDetails: null,
          },
        }
      ),
      createSetAuthorityInstruction(
        mint.publicKey,
        wallet.publicKey,
        AuthorityType.MintTokens,
        null
      )
    );

    tx.feePayer = wallet.publicKey;
    const { blockhash } = await connection.getLatestBlockhash();
    tx.recentBlockhash = blockhash;
    tx.partialSign(mint);

    const signedTx = await provider.signTransaction(tx);
    const sig = await connection.sendRawTransaction(signedTx.serialize());
    await connection.confirmTransaction(sig);

    const mintAddress = mint.publicKey.toBase58();
    // Build explorer URL properly
    const explorerUrl = networkSelect.value === 'mainnet-beta'
      ? `https://explorer.solana.com/address/${mintAddress}`
      : `https://explorer.solana.com/address/${mintAddress}?cluster=devnet`;

    showStatus(`Success! Token minted. Mint: ${mintAddress}`, false);
    // Open explorer in a new tab and also alert
    window.open(explorerUrl, '_blank');
    alert(`TOKEN LAUNCHED üöÄ\n\nMint: ${mintAddress}\nExplorer: ${explorerUrl}`);
  } catch (err) {
    console.error(err);
    showStatus('Transaction failed: ' + (err?.message || 'Unknown'), true);
  }
};

// Initial setup
updateWalletButton();
toggleForm(true);
</script>

</body>
</html><form id="form">
  <input id="name" placeholder="Token Name" required>
  <input id="symbol" placeholder="Symbol" maxlength="8" required>
  <input id="supply" type="number" placeholder="Total Supply" required>
  <input id="image" placeholder="Image URL (https://...png)">
  <textarea id="description" placeholder="Description"></textarea>
  <button type="submit">Launch Token</button>
</form>

</div>
</div>

<!-- LIBRARIES -->
<script src="https://unpkg.com/@solana/web3.js@latest/lib/index.iife.min.js"></script>
<script src="https://unpkg.com/@solana/spl-token@latest/lib/index.iife.min.js"></script>
<script src="https://unpkg.com/@metaplex-foundation/mpl-token-metadata@latest/dist/index.iife.js"></script>

<script>
const { 
  Connection, clusterApiUrl, Transaction, SystemProgram, Keypair, LAMPORTS_PER_SOL 
} = solanaWeb3;

const { 
  TOKEN_PROGRAM_ID, MINT_SIZE,
  getMinimumBalanceForRentExemptMint,
  createInitializeMintInstruction,
  getAssociatedTokenAddress,
  createAssociatedTokenAccountInstruction,
  createMintToInstruction,
  createSetAuthorityInstruction,
  AuthorityType
} = splToken;

const { 
  createCreateMetadataAccountV3Instruction,
  PROGRAM_ID: METADATA_PROGRAM_ID 
} = mplTokenMetadata;

// State variables
let wallet = null;
let connection = new Connection(clusterApiUrl('devnet'), 'confirmed');
let isConnecting = false;

// DOM elements
const walletBtn = document.getElementById('walletBtn');
const form = document.getElementById('form');
const networkSelect = document.getElementById('network');
const statusDiv = document.createElement('div'); // For feedback messages
statusDiv.style.marginTop = '1rem';
statusDiv.style.padding = '1rem';
statusDiv.style.borderRadius = '12px';
form.parentNode.insertBefore(statusDiv, form);

// Helper: Get Phantom provider
function getProvider() {
  if ('phantom' in window) {
    const provider = window.phantom?.solana;
    if (provider?.isPhantom) {
      return provider;
    }
  }
  return null;
}

// Disable/enable form
function toggleForm(disabled) {
  form.querySelectorAll('input,textarea,button,select').forEach(el => el.disabled = disabled);
}

// Show status message
function showStatus(msg, isError = false) {
  statusDiv.textContent = msg;
  statusDiv.style.background = isError ? 'rgba(239,68,68,0.15)' : 'rgba(34,197,94,0.15)';
  statusDiv.style.border = `1px solid ${isError ? '#ef4444' : '#22c55e'}`;
  statusDiv.style.color = isError ? '#fecaca' : '#bbf7d0';
}

// Update button text
function updateWalletButton() {
  if (wallet?.publicKey) {
    walletBtn.textContent = wallet.publicKey.toString().slice(0,6) + '‚Ä¶' + wallet.publicKey.toString().slice(-4);
    toggleForm(false);
  } else {
    walletBtn.textContent = 'Connect Phantom';
    toggleForm(true);
  }
}

// Network change
networkSelect.onchange = () => {
  connection = new Connection(clusterApiUrl(networkSelect.value), 'confirmed');
  if (networkSelect.value === 'mainnet-beta') {
    if (!confirm('‚ö†Ô∏è Switching to MAINNET ‚Äî real SOL will be spent! Continue?')) {
      networkSelect.value = 'devnet';
      connection = new Connection(clusterApiUrl('devnet'), 'confirmed');
    }
  }
  showStatus(`Connected to ${networkSelect.value.toUpperCase()}`);
};

// Connect handler
async function connectWallet(eager = false) {
  if (isConnecting) return;
  isConnecting = true;
  walletBtn.disabled = true;
  walletBtn.textContent = eager ? 'Auto-connecting...' : 'Connecting...';

  try {
    const provider = getProvider();
    if (!provider) {
      showStatus('Phantom not detected! Make sure you\'re using Phantom\'s in-app browser (globe icon).', true);
      throw new Error('No Phantom provider');
    }

    const params = eager ? { onlyIfTrusted: true } : {};
    const resp = await provider.connect(params);

    wallet = { publicKey: resp.publicKey };
    showStatus('Connected successfully! üéâ');
    updateWalletButton();
  } catch (err) {
    console.error(err);
    if (err.code === 4001) {
      showStatus('Connection rejected by user.', true);
    } else {
      showStatus('Connection failed: ' + (err.message || 'Unknown error'), true);
    }
    updateWalletButton();
  } finally {
    isConnecting = false;
    walletBtn.disabled = false;
  }
}

// Try eager connection on load (if previously trusted)
window.addEventListener('load', () => {
  connectWallet(true);
});

// Manual connect button
walletBtn.onclick = () => connectWallet(false);

// Form submission (your original logic, slightly cleaned)
form.onsubmit = async (e) => {
  e.preventDefault();
  if (!wallet?.publicKey) return;

  // ... (keep your existing form value collection, balance check, tx building)

  // Important: Use provider to sign instead of window.solana
  const provider = getProvider();
  if (!provider) return showStatus('Lost wallet connection!', true);

  try {
    showStatus('Preparing transaction...');
    // Build tx as before...

    tx.feePayer = wallet.publicKey;
    tx.recentBlockhash = (await connection.getLatestBlockhash()).blockhash;
    tx.partialSign(mint);

    const signedTx = await provider.signTransaction(tx);
    const sig = await connection.sendRawTransaction(signedTx.serialize());
    await connection.confirmTransaction(sig);

    const explorerBase = networkSelect.value === 'mainnet-beta'
      ? 'https://explorer.solana.com/address/'
      : 'https://explorer.solana.com/address/?cluster=devnet';

    showStatus(`Success! Token minted.\nMint: ${mint.publicKey.toBase58()}\n\nExplorer: \( {explorerBase} \){mint.publicKey.toBase58()}`, false);
    alert(`TOKEN LAUNCHED üöÄ\n\nMint: ${mint.publicKey.toBase58()}\nExplorer: \( {explorerBase} \){mint.publicKey.toBase58()}`);
  } catch (err) {
    console.error(err);
    showStatus('Transaction failed: ' + (err.message || 'Unknown'), true);
  }
};

// Initial setup
updateWalletButton();
toggleForm(true);
</script>

</body>
</html> 
