<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Solana Token Launchpad</title>
<style>
  body { font-family: system-ui, sans-serif; background:#0f0f1a; color:#e0e0ff; padding:1rem; }
  .container { max-width:620px; margin:auto; }
  .card { background:#1a1a2e; padding:1.5rem; border-radius:16px; border:1px solid #334155; }
  button, input, textarea, select { width:100%; padding:.8rem; margin-bottom:1rem; border-radius:10px; border:1px solid #334155; background:#111827; color:white; }
  button { background:#7c3aed; font-weight:bold; cursor:pointer; }
  .warning { background:rgba(245,158,11,.15); border:1px solid #f59e0b; padding:1rem; border-radius:12px; margin-bottom:1rem; }
  .note { font-size:0.9rem; color:#c7d2fe; margin-bottom:1rem;}
  .status { margin-top:1rem; padding:1rem; border-radius:12px; }
</style>
</head>
<body>
  <div class="container">
    <h2>Solana Token Launchpad</h2>
    <div class="warning">‚ö†Ô∏è Devnet by default. Mainnet uses REAL SOL. Do NOT use mainnet unless you understand costs.</div>

    <div class="card">
      <select id="network">
        <option value="devnet" selected>Devnet (testing)</option>
        <option value="mainnet-beta">Mainnet (REAL SOL)</option>
      </select>

      <button id="walletBtn">Connect Phantom</button>

      <form id="form">
        <input id="name" placeholder="Token Name" required />
        <input id="symbol" placeholder="Symbol (<=8 chars)" maxlength="8" required />
        <input id="supply" type="number" placeholder="Total Supply (integer)" required />
        <input id="image" placeholder="Image URL (https://...png) ‚Äî optional" />
        <textarea id="description" placeholder="Description (optional)"></textarea>
        <button type="submit">Launch Token</button>
      </form>

      <div id="status" class="status" style="display:none;"></div>
      <div class="note">
        Note: On-chain metadata typically expects an HTTP/HTTPS/IPFS/Arweave URI (not large data URIs). If you use an embedded data URI it may exceed metadata size limits or break indexers. Use IPFS/Arweave for production metadata.
      </div>
    </div>
  </div>

  <!-- Libraries (IIFE builds for browsers) -->
  <script src="https://unpkg.com/@solana/web3.js@latest/lib/index.iife.min.js"></script>
  <script src="https://unpkg.com/@solana/spl-token@latest/lib/index.iife.min.js"></script>
  <script src="https://unpkg.com/@metaplex-foundation/mpl-token-metadata@latest/dist/index.iife.js"></script>

  <script>
  (function () {
    const { Connection, clusterApiUrl, Transaction, SystemProgram, Keypair, LAMPORTS_PER_SOL, PublicKey } = solanaWeb3;
    const {
      TOKEN_PROGRAM_ID, MINT_SIZE,
      getMinimumBalanceForRentExemptMint,
      createInitializeMintInstruction,
      getAssociatedTokenAddress,
      createAssociatedTokenAccountInstruction,
      createMintToInstruction,
      createSetAuthorityInstruction,
      AuthorityType
    } = splToken;
    const {
      createCreateMetadataAccountV3Instruction,
      PROGRAM_ID: METADATA_PROGRAM_ID
    } = mplTokenMetadata;

    // State
    let wallet = null;
    let connection = new Connection(clusterApiUrl('devnet'), 'confirmed');
    let isConnecting = false;

    // DOM
    const walletBtn = document.getElementById('walletBtn');
    const form = document.getElementById('form');
    const networkSelect = document.getElementById('network');
    const statusDiv = document.getElementById('status');

    function showStatus(msg, isError = false) {
      statusDiv.style.display = 'block';
      statusDiv.textContent = msg;
      statusDiv.style.background = isError ? 'rgba(239,68,68,0.12)' : 'rgba(34,197,94,0.08)';
      statusDiv.style.border = `1px solid ${isError ? '#ef4444' : '#22c55e'}`;
      statusDiv.style.color = isError ? '#fecaca' : '#bbf7d0';
    }

    function hideStatus() {
      statusDiv.style.display = 'none';
    }

    function toggleForm(disabled) {
      form.querySelectorAll('input,textarea,button,select').forEach(el => el.disabled = disabled);
      networkSelect.disabled = disabled;
    }

    function updateWalletButton() {
      if (wallet?.publicKey) {
        const pk = wallet.publicKey.toString();
        walletBtn.textContent = pk.slice(0,6) + '‚Ä¶' + pk.slice(-4);
        toggleForm(false);
      } else {
        walletBtn.textContent = 'Connect Phantom';
        toggleForm(true);
      }
    }

    // Robust provider detection: prefer window.solana, then window.phantom?.solana
    function getProvider() {
      const p1 = window.solana && window.solana.isPhantom ? window.solana : null;
      const p2 = window.phantom?.solana && window.phantom.solana.isPhantom ? window.phantom.solana : null;
      return p1 || p2 || null;
    }

    // Network change
    networkSelect.onchange = () => {
      const newNet = networkSelect.value;
      connection = new Connection(clusterApiUrl(newNet), 'confirmed');
      if (newNet === 'mainnet-beta') {
        const ok = confirm('‚ö†Ô∏è Switching to MAINNET ‚Äî real SOL will be spent! Continue?');
        if (!ok) {
          networkSelect.value = 'devnet';
          connection = new Connection(clusterApiUrl('devnet'), 'confirmed');
          showStatus('Kept on DEVNET');
          return;
        }
      }
      showStatus(`Connected to ${newNet.toUpperCase()}`);
    };

    // Connect
    async function connectWallet(eager = false) {
      if (isConnecting) return;
      isConnecting = true;
      walletBtn.disabled = true;
      walletBtn.textContent = eager ? 'Auto-connecting...' : 'Connecting...';

      try {
        const provider = getProvider();
        if (!provider) {
          showStatus('Phantom not detected! Use Phantom in-app browser or install the extension.', true);
          throw new Error('No Phantom provider found');
        }

        const opts = eager ? { onlyIfTrusted: true } : {};
        const resp = await provider.connect(opts);
        wallet = { publicKey: resp.publicKey };
        showStatus('Connected successfully! üéâ');
        updateWalletButton();
      } catch (err) {
        console.error(err);
        if (err?.code === 4001) {
          showStatus('Connection rejected by user.', true);
        } else {
          showStatus('Connection failed: ' + (err?.message || err?.toString?.() || 'Unknown'), true);
        }
        wallet = null;
        updateWalletButton();
      } finally {
        isConnecting = false;
        walletBtn.disabled = false;
      }
    }

    // Eager connect if trusted
    window.addEventListener('load', () => connectWallet(true));
    walletBtn.onclick = () => connectWallet(false);

    // Small helper: turn JSON into base64 data URI (but we warn about size)
    function jsonToDataUri(obj) {
      const json = JSON.stringify(obj);
      const utf8 = new TextEncoder().encode(json);
      let str = '';
      for (let i = 0; i < utf8.length; i++) str += String.fromCharCode(utf8[i]);
      return 'data:application/json;base64,' + btoa(str);
    }

    // Validate integer supply
    function validateSupply(s) {
      if (!s) return false;
      const n = Number(s);
      return Number.isFinite(n) && n > 0 && Number.isInteger(n);
    }

    // Form submit
    form.onsubmit = async (e) => {
      e.preventDefault();
      hideStatus();

      if (!wallet?.publicKey) return showStatus('Wallet not connected', true);

      // Collect values
      const name = document.getElementById('name').value.trim();
      const symbol = document.getElementById('symbol').value.trim();
      const supplyStr = document.getElementById('supply').value;
      const image = document.getElementById('image').value.trim();
      const description = document.getElementById('description').value.trim();
      const decimals = 9; // standard on Solana SPL tokens

      if (!name || !symbol || !validateSupply(supplyStr)) {
        return showStatus('Invalid input: ensure name, symbol and an integer supply > 0 are provided', true);
      }
      if (symbol.length > 8) {
        return showStatus('Symbol must be <= 8 characters', true);
      }

      const provider = getProvider();
      if (!provider) return showStatus('Lost wallet connection!', true);

      try {
        showStatus('Preparing transaction...');

        // Balance check (small buffer)
        const balance = await connection.getBalance(wallet.publicKey);
        if (balance < Math.ceil(LAMPORTS_PER_SOL * 0.005)) {
          return showStatus('Insufficient SOL for fees/rent (need ~0.005 SOL)', true);
        }

        // Create mint
        const mint = Keypair.generate();
        const lamports = await getMinimumBalanceForRentExemptMint(connection);

        // Associated token account for payer
        const ata = await getAssociatedTokenAddress(mint.publicKey, wallet.publicKey);

        // Metadata PDA (Metaplex)
        const [metadataPDA] = PublicKey.findProgramAddressSync(
          [Buffer.from('metadata'), METADATA_PROGRAM_ID.toBuffer(), mint.publicKey.toBuffer()],
          METADATA_PROGRAM_ID
        );

        // Build metadata JSON (recommended: host this JSON on IPFS/Arweave and set uri to that)
        const metadataJson = {
          name,
          symbol,
          description,
          image: image || '',
          attributes: [],
          properties: {
            files: image ? [{ uri: image, type: 'image/png' }] : []
          }
        };

        // If you want to embed metadata as a data URI (only for quick tests), we support it but warn:
        const uri = jsonToDataUri(metadataJson);
        if (uri.length > 200) {
          // Many indexers and Metaplex tools expect uris under ~200 chars; reject to avoid corrupting metadata
          return showStatus('Metadata URI too large for on-chain metadata. Host JSON on IPFS or Arweave (recommended).', true);
        }

        const metadataData = {
          name,
          symbol,
          uri,
          sellerFeeBasisPoints: 0,
          creators: [],
          collection: null,
          uses: null
        };

        // Build transaction
        const tx = new Transaction();
        tx.add(
          SystemProgram.createAccount({
            fromPubkey: wallet.publicKey,
            newAccountPubkey: mint.publicKey,
            space: MINT_SIZE,
            lamports,
            programId: TOKEN_PROGRAM_ID
          }),
          createInitializeMintInstruction(
            mint.publicKey,
            decimals,
            wallet.publicKey, // mint authority
            wallet.publicKey  // freeze authority
          ),
          createAssociatedTokenAccountInstruction(
            wallet.publicKey, // payer
            ata,              // associated token account address
            wallet.publicKey, // owner of ATA
            mint.publicKey    // mint
          ),
          createMintToInstruction(
            mint.publicKey,
            ata,
            wallet.publicKey,
            BigInt(supplyStr) * (10n ** BigInt(decimals))
          ),
          createCreateMetadataAccountV3Instruction(
            {
              metadata: metadataPDA,
              mint: mint.publicKey,
              mintAuthority: wallet.publicKey,
              payer: wallet.publicKey,
              updateAuthority: wallet.publicKey
            },
            {
              createMetadataAccountArgsV3: {
                data: metadataData,
                isMutable: true,
                collectionDetails: null
              }
            }
          ),
          // Revoke minting ability by setting mint authority to null (optional)
          createSetAuthorityInstruction(
            mint.publicKey,
            wallet.publicKey,
            AuthorityType.MintTokens,
            null
          )
        );

        tx.feePayer = wallet.publicKey;
        const { blockhash } = await connection.getLatestBlockhash();
        tx.recentBlockhash = blockhash;

        // Partial sign with newly created mint keypair
        tx.partialSign(mint);

        // Ask wallet to sign the transaction
        const signedTx = await provider.signTransaction(tx);

        // Send
        const raw = signedTx.serialize();
        const txid = await connection.sendRawTransaction(raw);
        await connection.confirmTransaction(txid, 'confirmed');

        const mintAddress = mint.publicKey.toBase58();
        const explorerUrl = networkSelect.value === 'mainnet-beta'
          ? `https://explorer.solana.com/address/${mintAddress}`
          : `https://explorer.solana.com/address/${mintAddress}?cluster=devnet`;

        showStatus(`Success! Mint: ${mintAddress} ‚Äî tx: ${txid}`);
        window.open(explorerUrl, '_blank');
        alert(`TOKEN LAUNCHED üöÄ\n\nMint: ${mintAddress}\nExplorer: ${explorerUrl}`);
      } catch (err) {
        console.error(err);
        showStatus('Transaction failed: ' + (err?.message || err?.toString?.() || 'Unknown'), true);
      }
    };

    // Initial UI state
    updateWalletButton();
    toggleForm(true);
  })();
  </script>
</body>
</html>
 
